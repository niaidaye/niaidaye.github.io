## 1.1 面向对象特性？

- 封装：将数据和操作数据的代码封装在一起，隐藏内部实现细节，只暴露必要的接口。
- 继承：子类可以继承父类的属性和方法，并可以添加新的属性和方法。
- 多态：父类引用指向子类对象，调用子类的方法，实际执行的是子类的方法。

## 1.2 b = a + b 与 b += a 的区别?

```java
byte a = 127;
byte b = 127;

b = a + b; // error : cannot convert from int to byte
b += a; // 127 + 127 = 254
```
- `b = a + b` 首先将 `a` 与 `b` 进行运算，得到一个 `int` 结果，再将这个 `int` 结果赋值给 `b`。由于 `int` 类型变量可以容纳的最大值是 `2^31 - 1`，而 `byte` 类型变量可以容纳的最大值是 `2^7 - 1`，因此 `b = a + b` 语句会导致溢出。
- `b += a` 首先将 `a` 与 `b` 进行运算，得到一个 `int` 结果，再将这个 `int` 结果赋值给 `a`。由于 `int` 类型变量可以容纳的最大值是 `2^31 - 1`，而 `byte` 类型变量可以容纳的最大值是 `2^7 - 1`，因此 `b += a` 语句不会导致溢出。

因为: a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错,而 b+=a 操作只是将 a 与 b 进行相加，并将结果赋值给 b，所以不会导致溢出。
(注：`byte` 类型变量的取值范围是 `-128` 到 `127`，`int` 类型变量的取值范围是 `-2^31` 到 `2^31 - 1`)

## 1.3 3*0.1 == 0.3 将会返回什么? true 还是 false?
```java
System.out.println(3*0.1 == 0.3); // false
```
- 由于 `double` 类型变量的存储精度比 `float` 类型变量的存储精度更高，所以 `3*0.1` 的结果是一个 `double` 类型的值，而 `0.3` 是一个 `float` 类型的值。Java中认为 `3*0.1` 的结果是一个 `double` 类型的值，而 `0.3` 是一个 `float` 类型的值，所以 `3*0.1` 的结果是 `0.3`的近似值，因此 `3*0.1 == 0.3` 的结果为 `false`。 

## 1.4 在Swhtch中能使用String吗？

- 从 Java 7 开始，可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。
- 由于字符串的 hash code 值是唯一的，所以 switch case 语句中使用字符串时，不会出现冲突。
- 建议不要在 switch case 中使用字符串，因为它会降低代码的可读性。

## 1.5 对equals()和hashCode()的理解？

- `equals()` 方法用来判断两个对象是否相等，`hashCode()` 方法用来计算对象的哈希值，用于哈希表和集合等容器。
- `equals()` 方法应该遵循如下原则：
  - 自反性：对于任何非空引用值 x，`x.equals(x)` 应该返回 `true`。
  - 对称性：对于任何非空引用值 x 和 y，当且仅当 `y.equals(x)` 返回 `true` 时，`x.equals(y)` 应该返回 `true`。
  - 传递性：对于任何非空引用值 x、y 和 z，如果 `x.equals(y)` 返回 `true` 并且 `y.equals(z)` 返回 `true`，那么 `x.equals(z)` 应该返回 `true`。
  - 一致性：对于任何非空引用值 x 和 y，只要 `x` 和 `y` 的 `equals()` 方法返回相同的值，那么它们的 `hashCode()` 方法应该返回相同的值。
  - 对于任何非空引用值 x，`x.equals(null)` 应该返回 `false`。
- `hashCode()` 方法应该遵循如下原则：
  - 一致性：对于任何非空引用值 x，`x.hashCode()` 应该返回相同的值，不管何时调用。
  - 对于任何非空引用值 x，`x.equals(y)` 返回 `true`，那么 `x.hashCode()` 应该返回 `y.hashCode()` 的值。
  - 对于任何非空引用值 x，`x.equals(null)` 返回 `false`，那么 `x.hashCode()` 应该返回不同的值。

- 为什么在重写 `equals()` 方法时，需要同时重写 `hashCode()` 方法？
  - `equals()` 方法用来判断两个对象是否相等，`hashCode()` 方法用来计算对象的哈希值，用于哈希表和集合等容器。
  - 在 `HashMap`、`HashSet`、`Hashtable` 等容器中，`equals()` 方法用来判断两个对象是否相等，`hashCode()` 方法用来计算对象的哈希值，以便快速查找。
  - 如果 `equals()` 方法返回 `true`，则 `hashCode()` 方法返回相同的值，这就保证了 `HashMap`、`HashSet`、`Hashtable` 等容器中，相同的对象具有相同的哈希值。
  - 如果 `equals()` 方法返回 `false`，则 `hashCode()` 方法返回不同的哈希值，这就保证了 `HashMap`、`HashSet`、`Hashtable` 等容器中，不同的对象具有不同的哈希值。

- 有没有可能两个不同的对象具有相同的哈希值？
  - 理论上，有可能。但是，在实际应用中，很少会遇到这种情况。
  - 因为，哈希值是一个整数，整数的取值范围是有限的，如果哈希值相同，就会导致冲突。
  - 所以，在实际应用中，哈希值相同的概率非常小。如果确实遇到这种情况，可以考虑使用 `WeakHashMap`、`LinkedHashMap` 等容器，它们不会出现冲突。

- 两相等的对象会有不同的hashCode吗？
  - 不会有。如果两个对象相等，那么它们的hashCode也一定相等。
  - 但是，hashCode()方法返回的哈希值并不一定是唯一的。如果两个对象具有相同的hashCode()值，它们可能不相等。

## 1.6 final、finally、finalize有什么区别？

- `final` 关键字用来修饰类、方法、变量，用来表示常量。
- `finally` 关键字用来表示异常处理中的最后一步，用来声明一个块代码，无论是否出现异常都会执行。
- `finalize()` 方法用来垃圾回收器调用，用来释放对象资源。（注意：finalize() 方法是由垃圾回收器调用的，一般不应该显式调用。）

## 1.7 String、StringBuffer、StringBuilder有什么区别？

- `String` 类是不可变的，一旦创建就不能修改，适用于少量字符串的场景。
- `StringBuffer` 和 `StringBuilder` 类都是可变的，适用于对字符串进行修改的场景。其中，`StringBuffer` 是线程安全的，适合多线程环境，而 `StringBuilder` 是非线程安全的，适合单线程环境。
- `StringBuilder` 的效率高于 `StringBuffer`，因此在单线程环境中优先使用。

## 1.8 接口与抽象类有什么区别？

- 子类只能继承一个抽象类，但可以实现多个接口。
- 抽象类可以有构造方法，而接口没有。
- 抽象类可以包含普通成员变量，接口则不行。 
- 抽象类和接口都可以有静态成员变量，但抽象类中的静态成员变量可以有任意访问修饰符，而接口只能是 `public static final`（默认）。
- 抽象类可以没有抽象方法，并且可以有普通方法；接口在 JDK8 之前只能有抽象方法，JDK8 以后可以有 default 方法，JDK9 允许私有普通方法。
- 抽象类可以有静态方法；在 JDK8 之前接口不能有静态方法，JDK8 开始可以，但只能被接口内部调用。
- 抽象类的方法可以是 `public` 或 `protected`，而接口方法在 JDK8 之前只能是 `public abstract`，JDK8 及以后支持 default 方法，JDK9 允许私有方法。

## 1.9 this()和super() 在构造方法中的作用？

- `this()` 关键字用于调用本类的其他构造方法，`super()` 关键字用于调用父类的构造方法。
- `this()` 和 `super()` 必须作为构造方法的第一行，且只能在非静态的构造方法中使用。
- 不能在同一构造器中同时使用 `this()` 和 `super()`，否则编译会报错。
- `this` 指向本对象，`super` 用于访问父类成员，不可在静态环境中使用。
- 本质上，`this()` 是指向本对象的引用，`super()` 是指向父类的引用。

## 1.10 Java位移运算符有哪些？

- `<<` 左移运算符，将运算数的各二进位全部左移若干位，由低位丢弃，右边补0。`x << 1` 相当于 `x * 2`，`x << 2` 相当于 `x * 4`，以此类推。在不溢出的情况下，左移运算符是安全的。
- `>>` 右移运算符，将运算数的各二进位全部右移若干位，由高位丢弃，左边补0。`x >> 1` 相当于 `x / 2`，`x >> 2` 相当于 `x / 4`，以此类推。在不丢失任何信息的情况下，右移运算符是安全的。
- `>>>` 无符号右移运算符，将运算数的各二进位全部右移若干位，高位丢弃，左边补0。
