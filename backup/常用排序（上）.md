## 前言

---

带着问题来学习算法：

*插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？*

### 如何分析一个“排序算法”？

- **排序算法的执行效率**
  1. 最好、最坏、平均情况时间复杂度
  2. 时间复杂度的系数、常数、低阶
  3. 比较次数和交换（或移动）次数
- **排序算法的内存消耗**
  - 原地排序（Sorted in place）：特指空间复杂度为O(1)的排序算法
- **排序算法的稳定性**
  - 稳定性：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原来的先后顺序不变
  - 稳定排序算法：稳定性不变
  - 不稳定排序算法：稳定性发生改变

这里为什么要分析排序算法的稳定性，平时学习算法中，一般用数字来排序，两个3，大小不一样吗？在前，在后又有什么关系嘞？我这里举个， 实际开发中的例子，大家一看就能明白啦。

比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个，排序需求来说，一般我们会这样做：

我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。

借助一下稳定性算法，这个问题可以非常简洁高效地解决。

解决思路：

我们先按照订单时间进行排序，接着按照金额用一个稳定排序算法，经过两次排序算法后，就能得到需求。大家可以思考一下，为啥？

## 冒泡（bubbleSort）

---

冒泡排序，只会操作相邻的两个数据。每次冒泡操作都会对相邻两个元素进行比价，看是否满足大小关系。如果不满足就让它们互相交换

```java
   // 冒泡排序
    public static void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2)
            return; // 数组为空或长度小于2时，无需排序

        // 从前往后，每次把最大的数放到最后
        for (int end = arr.length - 1; end > 0; end--) {
            boolean flag = false; // 提前退出的标志

            // 从前往后，每次比较相邻的两个数，把大的数放到后面
            for (int i = 0; i < end; i++) {
                if (arr[i] > arr[i + 1]) { // 保证算法的稳定性
                    swap(arr, i, i + 1); // 交换
                    flag = true; // 有交换，说明还没有排好序
                }
            }
            if (!flag)
                break; // 没有交换，说明已经排好序，提前退出
        }
    }

// 交换
privat static void swap(int[] arr, int i, int j){
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

```

### 分析

- 冒泡排序是原地排序算法吗？

> 冒泡排序是原地算法；冒泡的过程只涉及相邻数据的交换操作，只需要常量级别的临时空间，所以它的空间复杂度是O(1)

- 冒泡排序是稳定的排序算法吗？

> 在冒泡排序中，只有交换才可以改变两个元素前后的顺序，可以为了保证冒泡排序算法的稳定性，在两个元素相等时候，不做交换

- 冒泡排序的时间复杂度是多少？

> 最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。

​	这里的时间复杂度，还可以通过“**有序度**”和“**逆序度**”来分析

#### 有序度

数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：

```math
有序元素对：a[i] <= a[j]，如果 i < j;
```

对于完全有序的数组有序度计算公式：（**满有序度**）

```math
n * (n - 1) / 2; n是数组元素个数;
```

#### 逆序度

计算公式：`逆序度 = 满有序度 - 有序度`

## 插入（Insertion Sort）

排序思想：

在一个有序的数组里添加一个元素，遍历有序数组，让元素插入到对应的位置，保证有序数组有序。——动态排序的过程；

插入排序的实现：将数组数据，分为两个区间，**已排序区间**、**未排序区间**。

首先初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

插入排序包含两种操作，一种**元素的比较**，一种**元素的移动**。

```java
// 插入排序
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2)
        return; // 数组为空或长度小于2时，无需排序

    // 从前往后，每次把第i个数插入到前面已经排好序的数组中
    for (int i = 1; i < arr.length; i++) {
        int value = arr[i]; // 要插入的数
        int j = i - 1; // 已经排好序的数组的最后一个数的下标

        boolean flag = true; // 提前退出的标志

        // 查找插入的位置
        while (j >= 0 && arr[j] > value) {
            flag = false;
            arr[j + 1] = arr[j]; // 移动数据
            j--; // 向前移动
        }
        if(flag) break; // 没有移动数据，说明已经排好序，提前退出
        // 插入数据
        arr[j + 1] = value;
    }
}
```

### 分析

- 插入排序是原地排序算法吗？

> 插入排序是原地算法；插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

- 插入排序是稳定的排序算法吗？

> 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。` arr[j + 1] = value;`

- 插入排序的时间复杂度是多少？

> 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是从尾到头遍历已经有序的数据。
>
> 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。
>
> 对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。

## 选择（Selection Sort）

排序思想：与插入排序类似，将分为**已排序区间**和**未排序区间**，每次从未排序区间找到最小元素，将其放入到已排序区间的末尾。

```java
// 选择排序
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2)
        return; // 数组为空或长度小于2时，无需排序

    boolean flag = true; // 提前退出的标志

    // 从前往后，每次把最小的数放到前面
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i; // 最小数的下标

        // 从i+1开始，找到最小的数的下标
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 更新最小数的下标
                flag = false; // 有交换，说明还没有排好序
            }
        }
        if (flag) // 没有交换，说明已经排好序，提前退出
            break;
        // 将找到的最小数与当前位置交换
        if (minIndex != i) {
            swap(arr, i, minIndex);
        }

    }
}

// 交换数组中两个元素的位置
public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### 分析

- 选择排序是原地排序算法吗？

> 选择排序空间复杂度为 O(1)，是一种原地排序算法。

- 选择排序是稳定的排序算法吗？

> 选择排序是一种不稳定的排序算法，因为选择排序每次都要找剩余未排序元素中的最小值，和前面元素交换，这样就破坏了，稳定性

- 选择排序的时间复杂度是多少？

> 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)

## 开篇答疑

> 插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？

冒泡、选择排序都涉及到，数据的交换

```java 
// 交换数组中两个元素的位置
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

而插入排序只涉及到，数据的移动

```java
arr[j + 1] = arr[j]; // 移动数据
```

当数据量大时候，冒泡、选择都要在，CPU中执行三次操作，而插入排序，就只需要在CPU中执行一次操作，这样速度就比较快啦；

