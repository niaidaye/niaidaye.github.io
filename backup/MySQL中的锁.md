# 锁机制详解
锁是计算机协调多个进程或线程并发访问某一资源的机制。
在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

# 锁的分类：

- 从**性能**上来分
    - **乐观锁**（用版本对比或者CAS机制）：适用读多写少的场景；
    - **悲观锁**：适用写多读少的场景；在写多读少的场景下，乐观锁会导致对比次数过多从而，影响性能

- 从**数据库操作粒度**分
    - **表锁**：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。
    - **页锁**：只有**BDB存储引擎支持页锁**，页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。
    - **行锁**（InnoDB）:每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。

- 从**数据库操作类型**分
    - **读锁**（共享锁、S锁（Shared））:针对同一份数据，多个读操作可以进行互不影响；
    ```sql
        select * from T where id = 1 lock in share mode;
    ```
    - **写锁**（排它锁，X锁（eXclusive））:当写操作没有完成前，会阻断其它写锁和读锁，数据修改操作都会加写锁，查询也可以通过for update加写锁，
    ```SQL
        select * from T where id = 1 for update;
    ```
    **读锁、写锁都属于悲观锁**
    - **意向锁**（Intention Lock）:又称I锁，针对表锁，主要是为了提高加表锁的效率，是mysql数据库自己加的。
        意向锁主要分为：
        - 意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁。
        - 意向排他锁，IX锁，对整个表加排他锁之前，需要先获取到意向排他锁。

## 间隙锁

锁的就是两个值之间的空隙，**间隙锁是在可重复读隔离级别下才会生效。**
Mysql默认级别是repeatable-read，有幻读问题，间隙锁是可以解决幻读问题的。
如：只要在间隙范围内锁了一条不存在的记录会锁住整个间隙范围，不锁边界记录，这样就能防止其它Session在这个间隙范围内插入数据，就解决了可重复读隔离级别的幻读问题。

## 临键锁(Next-key Locks)
Next-Key Locks是行锁与间隙锁的组合。