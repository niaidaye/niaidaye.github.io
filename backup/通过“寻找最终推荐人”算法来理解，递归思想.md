## 简单介绍一下“寻找最终推荐人”

有这样一个场景——推荐注册返回佣金的这个功能大家应该都不陌生。现在举个小栗子，用户A推荐用户B来注册，用户B又推荐用户C来注册。这个例子中，我们可以说，用户C的最终推荐人是，用户A、用户B的最终推荐人是用户A、用户A没有最终推荐人。

然后我们在数据库表中，记录这种推荐关系，字段actor_id 表示用户 id，字段referrer_id 表示推荐人 id。

![最终推荐人表结构](https://github.com/niaidaye/niaidaye.github.io/assets/27543204/b71b4093-bc5e-443e-8af7-68e6fff8eb90)


现在给予这个场景，给大家提一个问题：给定用户id，如何查到这个用户的“最终推荐人”？

相信大家都有不同的答案啦，那我这边有个三行代码就搞定的方法。——递归（Recursion）

## 理解递归

从资料中描述，递归是一种应用非常广泛的算法（或者编程技巧）。有很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归，对于算法学习非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。

别看这些描述，很高大上，其实我们生活中有很多都会用到递归的例子。

比如，周末跟你的好基友，去排队买烤鸭，现在你好基友想知道，排到第几个啦？如果队伍很长在加上，你的好基友是个近视，就不可能一个个数啦， 这个时候，你的好基友把问题，交给你身为程序员的你，怎么办？

这肯定就难不了你，递归就开始排上用场了。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。

这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：

```math
f(n) = f(n - 1) + 1; f(1) = 1
```

f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。同这个递推公式，我们就可以轻松的转化为递归代码，如下：

```java
public int function(int n){
  if(n == 1) return 1; 				// 对应f(1) = 1
  return function(n - 1) + 1; // 对应f(n) = f(n - 1) + 1
}
```

## 递归的三个条件

通过分析刚刚那个非常经典的递归问题，可以得出，满足递归三个条件的问题就可以用递归来，解决。

### 一个问题的解可以分解为几个子问题的解

何为子问题？子问题就是数据规模更小的问题。比如，前面讲的例子，要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。

### 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

比如前面那个例子，你求解“自己在哪一位”的思路，和前面一位人求解“自己在哪一位”的思路，是一模一样的。

### 存在递归终止条件

将问题分解成子问题，再把，子问题分解成子问题，一层层分解下去，但是不能无限的分解，这就需要一个终止条件。

还是排队的例子，第一排队的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。

## 编写递归代码

编写递归代码的关键就是**写出递推公式，找到终止条件**，剩下就是将递推公式转化为代码啦，

这里有个例子可以帮助你加深理解。

假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

可以分析一下

首先我们可以按照第一步走法，分为两类

- 第一类：第一步走啦一步
- 第二类：第一步走啦两步

所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：

```math
f(n) = f(n - 1) + f(n - 2)
```

有啦，递推公式，接下就要来分析终止条件了；

当最后只有一个台阶，也就只有一种走法，就是f(1) = 1，但是只有这个终止条件够吗？我们可以将n = 2、n = 3带入验证一下

```math
f(2) = f(2 - 1) + f(2 - 2);f(3) = f(3 - 1) + f(3 - 2)
```

可以看出，当n =  2时，会出现， f(2) = f(1) + f(0)，那么由于 f(0)这里未定义，就无法计算了，所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法。当然这样看起来太符合逻辑，我们更改一下，让f(2) = 2作为终止条件，它表示的含义是，当最后还剩下两台阶时，这里就有两类走法，一次走两步、一次走一步。

将递推公式和终止条件结合在一起是这样的

```math
f(n) = f(n - 1) + f(n - 2);| f(2) = 2;f(1) = 1
```

有了这个公式，在进行代码转换如下：

```java
public int function(int n){
  if(n = 2) return 2;
  if(n = 1) return 1;
  return function(n - 1) + function(n - 2);
}
```

总结一下：**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码**

回到开篇提到的最终推荐人的问题， 我的解决方案是这样的

```java
public long findRootReferrerId(long actorId) {
  Long referrerId = mapper.getReferrerId(actorId);
  if(referrerId == null) return actorId;
  return findRootReferrerId(referrerId);
}
```

```sql
// mapper 对应的sql
select referrer_id from [table] where actor_id = actorId;
```

但是这个方案还有优惠空间，比如：递归很深，可能会出现，堆内存溢出、如果出现脏数据，A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。这些问题后面学习中慢慢优化吧