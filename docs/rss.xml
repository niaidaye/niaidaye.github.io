<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>独钓寒江雪的博客</title><link>https://niaidaye.github.io</link><description>我是AX，分享输出学习过中的一点点心得，愿与君共勉。您的点赞👍，收藏⭐️，是我创作路上的绊脚石，🤣</description><copyright>独钓寒江雪的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/27543204?v=4</url><title>avatar</title><link>https://niaidaye.github.io</link></image><lastBuildDate>Thu, 07 Nov 2024 15:42:55 +0000</lastBuildDate><managingEditor>独钓寒江雪的博客</managingEditor><ttl>60</ttl><webMaster>独钓寒江雪的博客</webMaster><item><title>Nginx学习笔记</title><link>https://niaidaye.github.io/post/Nginx-xue-xi-bi-ji.html</link><description>## Nginx是什么？&#13;
&#13;
是一个http服务器，Nginx是一款高性能的http服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器&#13;
&#13;
## 能干什么？&#13;
&#13;
- 可以作为Web服务器&#13;
- 可以作为邮件服务器&#13;
- 可以作为反向代理的服务器&#13;
- 动静分离（就是将动态资源和静态资源分隔开）&#13;
- 可以实现负载均衡&#13;
&#13;
## 安装步骤：&#13;
&#13;
百度、Google、等等&#13;
&#13;
## 配置文件：&#13;
&#13;
```json&#13;
#user  nobody;&#13;
#工作的线程(4核8线程那么下面就设置成8 物理硬件有关)&#13;
worker_processes  1;&#13;
&#13;
#全局的错误日志存放的地方&#13;
#error_log  logs/error.log;&#13;
&#13;
#全局错误日志存放的地方 后面的notice表示的是输出错误日志的格式&#13;
#error_log  logs/error.log  notice;&#13;
#error_log  logs/error.log  info;&#13;
&#13;
#nginx进程号存放的地方&#13;
#pid        logs/nginx.pid;&#13;
#最大的连接数(这个也跟硬件是有关系的)&#13;
events {&#13;
    worker_connections  1024;&#13;
}&#13;
#下面就是跟HTTP请求有关系的了&#13;
http {&#13;
    #表示的是当前服务器支持的类型&#13;
    include       mime.types;&#13;
    #默认传输的数据类型是流 &#13;
    default_type  application/octet-stream;&#13;
&#13;
    #声明了一种日志格式 这种日志格式的名字叫做  main&#13;
    log_format  main  '$remote_addr - $remote_user [$time_local] '$request' '&#13;
                      '$status $body_bytes_sent '$http_referer' '&#13;
                      ''$http_user_agent' '$http_x_forwarded_for'';&#13;
&#13;
    #表示的是每一次请求的日志记录 格式就是上面的main格式&#13;
    access_log  logs/access.log  main;&#13;
    &#13;
    #是否可以发送文件&#13;
    sendfile        on;&#13;
    #tcp_nopush     on;&#13;
&#13;
    #这个是双活的超时的时间&#13;
    #keepalive_timeout  0;&#13;
    keepalive_timeout  65;&#13;
&#13;
    #是否打开文件的压缩&#13;
    #gzip  on;&#13;
&#13;
    #虚拟一个主机&#13;
   &#13;
   #负载均衡的配置&#13;
   upstream qianyu {&#13;
      ip_hash;&#13;
      server 10.7.182.110:8080;&#13;
      server 10.7.182.87:8080;&#13;
   }&#13;
&#13;
    #server {&#13;
      # listen     90;&#13;
      # server_name localhost; &#13;
      # location / {&#13;
      #    root qianyu;&#13;
      #    index qianyu.html;&#13;
      # }&#13;
      #做一个反向代理&#13;
      #表示的是 如果你访问的后缀是 .jpg结尾的话那么 就访问下面的另外的服务器&#13;
       # location ~ \.jpg$ {&#13;
       #     proxy_pass   http://10.7.182.110:8080;&#13;
       # }&#13;
&#13;
      #下面要演示一个负载均衡的例子&#13;
       #location ~ \.jpg$ {&#13;
       #    proxy_pass   http://qianyu;&#13;
       #}&#13;
    #}&#13;
&#13;
   #虚拟一个动静分离的机器&#13;
   server {&#13;
     listen     9999;&#13;
     server_name localhost;&#13;
     &#13;
     #表示的是动态资源访问的机器&#13;
&#13;
      location / {&#13;
            proxy_pass   http://10.7.182.54:8080;&#13;
      }&#13;
    #表示的是非  css和js文件访问的地址&#13;
    location ~ .*\.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#13;
        {&#13;
            root /usr/local/webapp;&#13;
            expires 30d;&#13;
        }&#13;
      #表示的是css和js的访问地址&#13;
      location ~ .*\.(js|css)?$&#13;
       {&#13;
         root /usr/local/webapp;&#13;
         expires 1h;&#13;
       }&#13;
&#13;
  }&#13;
&#13;
    #虚拟了服务器&#13;
    server {&#13;
        #端口是  80&#13;
        listen       80;&#13;
        #这个表示的是虚拟服务器默认访问的是本机&#13;
        server_name  localhost;&#13;
        #这个是虚拟服务器的编码&#13;
        #charset koi8-r;&#13;
        #当前服务器的日志的存储的地方&#13;
        #access_log  logs/host.access.log  main;&#13;
&#13;
        #做了一个地址的映射&#13;
        location / {&#13;
            root   html;&#13;
            index  index.html index.htm;&#13;
        }&#13;
        &#13;
        #如果报404的时候访问的页面&#13;
        #error_page  404              /404.html;&#13;
&#13;
        # redirect server error pages to the static page /50x.html&#13;
        #报错50开头的是 就访问50x.html&#13;
        error_page   500 502 503 504  /50x.html;&#13;
        #下面对50x.html又做了一个映射  就访问根目录下的html中的  50x.html&#13;
        location = /50x.html {&#13;
            root   html;&#13;
        }&#13;
&#13;
        # proxy the PHP scripts to Apache listening on 127.0.0.1:80&#13;
        #&#13;
        #location ~ \.php$ {&#13;
        #    proxy_pass   http://127.0.0.1;&#13;
        #}&#13;
&#13;
        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000&#13;
        #&#13;
        #location ~ \.php$ {&#13;
        #    root           html;&#13;
        #    fastcgi_pass   127.0.0.1:9000;&#13;
        #    fastcgi_index  index.php;&#13;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;&#13;
        #    include        fastcgi_params;&#13;
        #}&#13;
&#13;
        # deny access to .htaccess files, if Apache's document root&#13;
        # concurs with nginx's one&#13;
        #&#13;
        #location ~ /\.ht {&#13;
        #    deny  all;&#13;
        #}&#13;
    }&#13;
    # another virtual host using mix of IP-, name-, and port-based configuration&#13;
    #&#13;
    #server {&#13;
    #    listen       8000;&#13;
    #    listen       somename:8080;&#13;
    #    server_name  somename  alias  another.alias;&#13;
&#13;
    #    location / {&#13;
    #        root   html;&#13;
    #        index  index.html index.htm;&#13;
    #    }&#13;
    #}&#13;
    # HTTPS server&#13;
    #&#13;
    #server {&#13;
    #    listen       443 ssl;&#13;
    #    server_name  localhost;&#13;
&#13;
    #    ssl_certificate      cert.pem;&#13;
    #    ssl_certificate_key  cert.key;&#13;
&#13;
    #    ssl_session_cache    shared:SSL:1m;&#13;
    #    ssl_session_timeout  5m;&#13;
&#13;
    #    ssl_ciphers  HIGH:!aNULL:!MD5;&#13;
    #    ssl_prefer_server_ciphers  on;&#13;
&#13;
    #    location / {&#13;
    #        root   html;&#13;
    #        index  index.html index.htm;&#13;
    #    }&#13;
    #}&#13;
&#13;
}&#13;
&#13;
```&#13;
&#13;
## 反向代理&#13;
&#13;
```json&#13;
location ~ \.jpg$ {&#13;
            proxy_pass   http://10.7.182.110:8080;&#13;
        }&#13;
```&#13;
&#13;
## 实现Nginx下的负载均衡&#13;
&#13;
- **默认是轮循的策略：**&#13;
&#13;
```json&#13;
配置upstream&#13;
   upstream qianyu {&#13;
      server 10.7.182.110:8080;&#13;
      server 10.7.182.87:8080;&#13;
   }&#13;
   配置负载均衡&#13;
   location ~ \.jpg$ {&#13;
           proxy_pass   http://qianyu;&#13;
   }&#13;
```&#13;
&#13;
- **权重（weight）：**&#13;
&#13;
```json&#13;
#负载均衡的配置&#13;
  upstream qianyu {&#13;
     server 10.7.182.110:8080 weight=2;&#13;
     server 10.7.182.87:8080 weight=1;&#13;
  }&#13;
 配置负载均衡&#13;
     location ~ \.jpg$ {&#13;
           proxy_pass   http://qianyu;&#13;
     }&#13;
&#13;
```&#13;
&#13;
- **IPHash的使用：**&#13;
&#13;
```json&#13;
 #负载均衡的配置&#13;
   upstream qianyu {&#13;
      ip_hash;&#13;
      server 10.7.182.110:8080;&#13;
      server 10.7.182.87:8080;&#13;
   }&#13;
配置负载均衡&#13;
    location ~ \.jpg$ {&#13;
           proxy_pass   http://qianyu;&#13;
    }&#13;
&#13;
```&#13;
&#13;
## 动静分离&#13;
&#13;
```json&#13;
#虚拟一个动静分离的机器&#13;
   server {&#13;
     listen     9999;&#13;
     server_name localhost;&#13;
&#13;
     #表示的是动态资源访问的机器&#13;
&#13;
      location / {&#13;
            proxy_pass   http://10.7.182.54:8080;&#13;
      }&#13;
    #表示的是非  css和js文件访问的地址&#13;
    location ~ .*\.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#13;
        {&#13;
            root /usr/local/webapp;&#13;
            expires 30d;&#13;
        }&#13;
      #表示的是css和js的访问地址&#13;
      location ~ .*\.(js|css)?$&#13;
  {&#13;
         root /usr/local/webapp;&#13;
         expires 1h;&#13;
       }&#13;
&#13;
  }&#13;
```&#13;
&#13;
## 虚拟主机&#13;
&#13;
```json&#13;
server {&#13;
       listen     90;&#13;
       server_name localhost;&#13;
       location / {&#13;
          root qianyu;&#13;
          index qianyu.html;&#13;
       }&#13;
      #做一个反向代理&#13;
      #表示的是 如果你访问的后缀是 .jpg结尾的话那么 就访问下面的另外的服务器&#13;
        location ~ \.jpg$ {&#13;
            proxy_pass   http://10.7.182.110:8080;&#13;
        }&#13;
}&#13;
```&#13;
&#13;
## 常用命令&#13;
&#13;
1. ps aux | grep nginx 查看nginx运行状态&#13;
2. systemctl  start  nginx.service  启动nginx&#13;
3. nginx -s stop  立即停止nginx服务&#13;
4. nginx -s quit  从容停止&#13;
5. killall  nginx 杀死所有的nginx 进程&#13;
6. systemctl   stop nginx.service  停止nginx服务器&#13;
7. systemctl   restart  ngnix.service  重启nginx服务器&#13;
8. nginx  -s  reload   重新载入配置文件文件&#13;
&#13;
## 文件位置&#13;
&#13;
1. rpm  -ql  nginx    查看nginx安装列表，可以看到nginx所有的安装位置&#13;
2. 总配置文件：/etc/nginx/nginx.conf&#13;
3. /etc/nginx/conf.d  所有的nginx自定义配置文件&#13;
4. /var/log/nginx/error.log  错误日志文件&#13;
5. /usr/share/nginx/html   服务器默认启动目录。</description><guid isPermaLink="true">https://niaidaye.github.io/post/Nginx-xue-xi-bi-ji.html</guid><pubDate>Thu, 07 Nov 2024 15:41:30 +0000</pubDate></item><item><title>JSON Web Token（JWT）解决什么问题？</title><link>https://niaidaye.github.io/post/JSON%20Web%20Token%EF%BC%88JWT%EF%BC%89-jie-jue-shen-me-wen-ti-%EF%BC%9F.html</link><description>JSON Web Token (JWT) 主要解决了以下几个问题：&#13;
&#13;
## 1. 身份认证和授权&#13;
&#13;
JWT 提供了一种安全、可靠的方式来验证用户身份和授权访问权限。</description><guid isPermaLink="true">https://niaidaye.github.io/post/JSON%20Web%20Token%EF%BC%88JWT%EF%BC%89-jie-jue-shen-me-wen-ti-%EF%BC%9F.html</guid><pubDate>Mon, 21 Oct 2024 14:49:49 +0000</pubDate></item><item><title>MySQL死锁是怎么排查的？</title><link>https://niaidaye.github.io/post/MySQL-si-suo-shi-zen-me-pai-cha-de-%EF%BC%9F.html</link><description>MySQL死锁的排查是一个重要的数据库管理任务。</description><guid isPermaLink="true">https://niaidaye.github.io/post/MySQL-si-suo-shi-zen-me-pai-cha-de-%EF%BC%9F.html</guid><pubDate>Sat, 19 Oct 2024 09:08:41 +0000</pubDate></item><item><title>Spring 基础知识</title><link>https://niaidaye.github.io/post/Spring%20-ji-chu-zhi-shi.html</link><description>## 1. Spring和Spring框架&#13;
&#13;
Spring是一个开源的Java开发框架，由Pivotal团队开发，是目前最流行的Java开发框架之一。</description><guid isPermaLink="true">https://niaidaye.github.io/post/Spring%20-ji-chu-zhi-shi.html</guid><pubDate>Tue, 15 Oct 2024 15:13:28 +0000</pubDate></item><item><title>Java知识点-基础语法</title><link>https://niaidaye.github.io/post/Java-zhi-shi-dian---ji-chu-yu-fa.html</link><description># 1. 语法基础&#13;
&#13;
## 1.1 面向对象特性？&#13;
&#13;
- 封装：将数据和操作数据的代码封装在一起，隐藏内部实现细节，只暴露必要的接口。</description><guid isPermaLink="true">https://niaidaye.github.io/post/Java-zhi-shi-dian---ji-chu-yu-fa.html</guid><pubDate>Mon, 14 Oct 2024 13:15:23 +0000</pubDate></item><item><title>MySQL中的锁</title><link>https://niaidaye.github.io/post/MySQL-zhong-de-suo.html</link><description># 锁机制详解&#13;
锁是计算机协调多个进程或线程并发访问某一资源的机制。</description><guid isPermaLink="true">https://niaidaye.github.io/post/MySQL-zhong-de-suo.html</guid><pubDate>Sun, 13 Oct 2024 15:31:39 +0000</pubDate></item><item><title>常用排序（上）</title><link>https://niaidaye.github.io/post/chang-yong-pai-xu-%EF%BC%88-shang-%EF%BC%89.html</link><description>## 前言&#13;
&#13;
---&#13;
&#13;
带着问题来学习算法：&#13;
&#13;
*插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？*&#13;
&#13;
### 如何分析一个“排序算法”？&#13;
&#13;
- **排序算法的执行效率**&#13;
  1. 最好、最坏、平均情况时间复杂度&#13;
  2. 时间复杂度的系数、常数、低阶&#13;
  3. 比较次数和交换（或移动）次数&#13;
- **排序算法的内存消耗**&#13;
  - 原地排序（Sorted in place）：特指空间复杂度为O(1)的排序算法&#13;
- **排序算法的稳定性**&#13;
  - 稳定性：待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原来的先后顺序不变&#13;
  - 稳定排序算法：稳定性不变&#13;
  - 不稳定排序算法：稳定性发生改变&#13;
&#13;
这里为什么要分析排序算法的稳定性，平时学习算法中，一般用数字来排序，两个3，大小不一样吗？在前，在后又有什么关系嘞？我这里举个， 实际开发中的例子，大家一看就能明白啦。</description><guid isPermaLink="true">https://niaidaye.github.io/post/chang-yong-pai-xu-%EF%BC%88-shang-%EF%BC%89.html</guid><pubDate>Tue, 09 Jul 2024 09:30:45 +0000</pubDate></item><item><title>MySQL（InnoDB）事务的多版本并发控制（二）</title><link>https://niaidaye.github.io/post/MySQL%EF%BC%88InnoDB%EF%BC%89-shi-wu-de-duo-ban-ben-bing-fa-kong-zhi-%EF%BC%88-er-%EF%BC%89.html</link><description>对于上次提到的事务 A、B、C 的执行流程，这里我在放上这张图&#13;
&#13;
![事务A、B、C执行流程(1)](https://github.com/niaidaye/niaidaye.github.io/assets/27543204/5df7814d-c482-403d-bdfa-4a9d1cba08bc)&#13;
&#13;
最后执行的查询，结果相信大家都有所了解啦， 事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1。</description><guid isPermaLink="true">https://niaidaye.github.io/post/MySQL%EF%BC%88InnoDB%EF%BC%89-shi-wu-de-duo-ban-ben-bing-fa-kong-zhi-%EF%BC%88-er-%EF%BC%89.html</guid><pubDate>Fri, 05 Jul 2024 07:44:53 +0000</pubDate></item><item><title>通过“寻找最终推荐人”算法来理解，递归思想</title><link>https://niaidaye.github.io/post/tong-guo-%E2%80%9C-xun-zhao-zui-zhong-tui-jian-ren-%E2%80%9D-suan-fa-lai-li-jie-%EF%BC%8C-di-gui-si-xiang.html</link><description>## 简单介绍一下“寻找最终推荐人”&#13;
&#13;
有这样一个场景——推荐注册返回佣金的这个功能大家应该都不陌生。</description><guid isPermaLink="true">https://niaidaye.github.io/post/tong-guo-%E2%80%9C-xun-zhao-zui-zhong-tui-jian-ren-%E2%80%9D-suan-fa-lai-li-jie-%EF%BC%8C-di-gui-si-xiang.html</guid><pubDate>Thu, 04 Jul 2024 02:55:22 +0000</pubDate></item><item><title>MySQL（InnoDB）事务的多版本并发控制（一）</title><link>https://niaidaye.github.io/post/MySQL%EF%BC%88InnoDB%EF%BC%89-shi-wu-de-duo-ban-ben-bing-fa-kong-zhi-%EF%BC%88-yi-%EF%BC%89.html</link><description>---&#13;
&#13;
最近刚，学到MySQL事务相关的，知识点，想和大家简单聊聊，在MySQL的InnoDB引擎中是如何多个事务同时执行如何保证数据的一致性。</description><guid isPermaLink="true">https://niaidaye.github.io/post/MySQL%EF%BC%88InnoDB%EF%BC%89-shi-wu-de-duo-ban-ben-bing-fa-kong-zhi-%EF%BC%88-yi-%EF%BC%89.html</guid><pubDate>Tue, 02 Jul 2024 12:56:33 +0000</pubDate></item><item><title>OneDay——记录生活</title><link>https://niaidaye.github.io/post/OneDay%E2%80%94%E2%80%94-ji-lu-sheng-huo.html</link><description>## 不一样的开始&#13;
&#13;
​	想跟大家，聊聊这个博客的想法吧，其实从一开始读大学，就开始有想写，个人博客的想法，以前研究过，hexo、通过云服务+WordPress呀，等等但是由于，种种原因吧， 都没坚持✊下来，以前写的文章也没有保存下来，蛮可惜的😂&#13;
&#13;
​	机缘巧合下，看见b站up主——[技术爬爬虾](https://space.bilibili.com/316183842)分享的[仅需一个Github账号，让文字在互联网中永生](https://www.bilibili.com/video/BV1GM4m1m7ZD/)视频，其中一句话引起我的共鸣“如果你想写一段文字，让100年后的人也能访问到，你会写在哪里？”。</description><guid isPermaLink="true">https://niaidaye.github.io/post/OneDay%E2%80%94%E2%80%94-ji-lu-sheng-huo.html</guid><pubDate>Sat, 29 Jun 2024 04:30:03 +0000</pubDate></item></channel></rss>